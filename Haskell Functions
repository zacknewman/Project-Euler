{- |
Module      : projectEuler
Description : Project Euler functions
Copyright   : (c) Zack Newman
License     :

Maintainer  : zacknewman22@gmail.com
Stability   : stable
Portability : portable

The projectEuler module contains functions to calculate some of the problems
from Project Euler.
-}

-- |The sumConsecNumbers function adds every integer separated by a constant
-- integer bounded by two integers.
sumConsecNumbers      :: Integer -> Integer -> Integer -> Integer
sumConsecNumbers i n j = (2 * i + m * j) * (m + 1) `div` 2
    where m = (n - i) `div` j

-- |The sumMultiple function sums all multiples of an integer bounded by two
-- integers.
sumMultiple      :: Integer -> Integer -> Integer -> Integer
sumMultiple i m n = sumConsecNumbers j n i
    where j = i * (ceiling ((fromIntegral m::Double) /
              (fromIntegral i::Double))::Integer)

-- |The fibAll function creates the infinite list of Fibonacci integers.
fibAll :: [Integer]
fibAll  = 0:1:zipWith (+) fibAll (tail fibAll)

-- |The fibDiv function creates the list of Fibonacci integers bounded by an
-- integer and divisible by another integer.
fibDiv    :: Integer -> Integer -> [Integer]
fibDiv i n = filter (\ k -> k `mod` i == 0) $ takeWhile (<= n) fibAll

-- |The factorization function creates a list of the prime factorization of any
-- positive integer.
factorization  :: Integer -> [Integer]
factorization 1 = []
factorization n = p:factorization (n `div` p)
        where p = head $ filter (\ x -> n `mod` x == 0) (2:[3,5..round $ sqrt
                  (fromIntegral n::Double)]++[n])

-- |The toDigits function maps a non-negative integer into a list of the
-- integer's digit(s).
toDigits       :: Integer -> [Integer]
toDigits n
    | n < 0     = error "Argument must be a non-negative integer."
    | n > 9     = toDigits (n `div` 10) ++ [n `mod` 10]
    | otherwise = [n]

-- |The palindromicNumber function tests if a non-negative integer is a
-- palindromic integer.
palindromicNumber  :: Integer -> Bool
palindromicNumber n = toDigits n == reverse (toDigits n)

-- |The palindromeProduct produces the largest palindromic integer that is a
-- product of two non-negative n-digit integers.
palindromeProduct :: Integer -> Integer
palindromeProduct n = maximum $ filter palindromicNumber xs
    where xs = [i * j | i <- [10 ^ (n - 1)..10 ^ n - 1], j <- [10 ^ (n - 1)..10
                ^ n - 1]]

-- |The prime function tests if an integer is prime.
prime  :: Integer -> Bool
prime n = [n] == factorization n

-- |The allPrimes function produces the list of all primes.
allPrimes :: [Integer]
allPrimes  = filter prime (2:[3,5..])

-- |The smallestMultiple function produces the smallest integer that is a
-- multiple of every integer from 1 to n.
smallestMultiple  :: Int -> Integer
smallestMultiple n = foldl f 1 $ take n allPrimes
    where f = \ q p -> p ^ (floor $ log (fromIntegral n::Double) / log
              (fromIntegral p::Double)::Integer) * q

-- |The sumConsecSquares function adds the square of every integer separated by
-- a constant integer bounded by two integers.
sumConsecSquares      :: Integer -> Integer -> Integer -> Integer
sumConsecSquares i n j = ((m + 1) * (m * j * (6 * i + j * (2 * m + 1)) + 6 *
                         toInteger i ^ (2::Integer))) `div` 6
    where m = (n - i) `div` j

-- |The primeNumber function returns the nth prime integer (indexed from 0).
primeNumber  :: Integer -> Integer
primeNumber n = last $ zipWith (\ a b -> a + b - a) [0..n] allPrimes

main :: IO()
main  = do print (sumMultiple 3 1 999 + sumMultiple 5 1 999 - sumMultiple 15 1
                  999)
           print (sum $ fibDiv 2 4000000)
           print (last $ factorization 600851475143)
           print (palindromeProduct 3)
           print (smallestMultiple 20)
           print (sumConsecNumbers 1 100 1 ^ (2::Integer) - sumConsecSquares 1
                  100 1)
           print (primeNumber 10000)
