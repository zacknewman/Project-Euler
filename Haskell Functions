{- |
Module      : projectEuler
Description : Project Euler functions
Copyright   : (c) Zack Newman
License     :

Maintainer  : zacknewman22@gmail.com
Stability   : stable
Portability : portable

The projectEuler module contains functions to calculate some of the problems
from Project Euler.
-}

import Data.List as Listfunctions

-- |The sumConsecNumbers function returns the sum of the first n numbers
-- beginning from i. The only parameter that requires a positive integer is n.
-- The function is defined over the RealFloat typeclass for the other two
-- parameters. The function returns the sum of i, i + j, i + 2*j,...,
-- i + (n - 1)*j.
sumConsecNumbers :: (RealFloat a, Integral b) => a -> b -> a -> a
sumConsecNumbers i n j = (m + 1) * i + (m ^ (2::Integer) + m) * j / 2
    where m = fromIntegral (n - 1)

-- |The sumMultiple function sums the first n multiples of i starting
-- from m. The only parameter that must be a positive integer is n.
-- The other two parameters are defined for all RealFloat typeclass.
-- The function takes the sum of all integer multiples of i starting from m.
-- If m is not a multiple of i, then the smallest multiple of i that's >= m is
-- the starting point.
sumMultiple      :: (RealFloat a, Integral b) => a -> a -> b -> a
sumMultiple i m n = sumConsecNumbers j n i
    where j = i * fromIntegral (ceiling (m / i )::Integer)

-- |The fibAll function creates the infinite list of Fibonacci integers.
fibAll :: [Integer]
fibAll  = 0:1:zipWith (+) fibAll (tail fibAll)

-- |The fibDiv function creates the list of Fibonacci integers bounded by an
-- integer and divisible by another integer.
fibDiv    :: Integer -> Integer -> [Integer]
fibDiv i n = filter (\ k -> k `mod` i == 0) $ takeWhile (<= n) fibAll

-- |The factorization function creates a list of the prime factorization of any
-- positive integer. This function is a rather simple implementation that can be
-- greatly improved (e.g., general number field sieve), and so should only be
-- used for integers up to 20-digits in length.
factorization  :: Integer -> [Integer]
factorization 1 = []
factorization n = p:factorization (n `div` p)
        where p = head $ filter (\ x -> n `mod` x == 0) (2:[3,5..round $ sqrt
                  (fromIntegral n::Double)] ++ [n])

-- |The toDigits function maps a non-negative integer into a list of the
-- integer's digit(s).
toDigits       :: Integer -> [Integer]
toDigits n
    | n < 0     = error "Argument must be a non-negative integer."
    | n > 9     = toDigits (n `div` 10) ++ [n `mod` 10]
    | otherwise = [n]

-- |The palindromicNumber function tests if a non-negative integer is a
-- palindromic integer.
palindromicNumber  :: Integer -> Bool
palindromicNumber n = toDigits n == reverse (toDigits n)

-- |The palindromeProduct produces the largest palindromic integer that is a
-- product of two non-negative n-digit integers.
palindromeProduct :: Integer -> Integer
palindromeProduct n = maximum $ filter palindromicNumber xs
    where xs = [i * j | i <- [10 ^ (n - 1)..10 ^ n - 1], j <- [10 ^ (n - 1)..10
                ^ n - 1]]

-- |The composite function tests if an integer is composite. The function
-- employs Fermat's Little Theorem which works for all non-Carmichael composite
-- numbers. The function outputs False for numbers less than 2,
-- prime numbers, and Carmichael composite numbers; therefore only True
-- outputs should be considered.
composite  :: Integer -> Bool
composite n
    | n <= 2         = False
    | n `mod` 2 == 0 = True
    | otherwise = 2 ^ (n - 1) `mod` n /= 1

-- |The prime function tests if an integer is prime. This is a very simple
-- function that first tests if a number is composite using the "composite"
-- function, then factorizes the number to test its primality. Consequently this
-- function may take a lot of time to compute if the number exceeds 20 digits.
-- In the case of very large integers one must employ sieve theory techniques.
prime  :: Integer -> Bool
prime n = if composite n then False else factorization n == [n]

-- |The allPrimes function produces the list of all primes.
allPrimes :: [Integer]
allPrimes  = filter prime (2:[3,5..])

-- |The smallestMultiple function produces the smallest integer that is a
-- multiple of every integer from 1 to n.
smallestMultiple  :: Int -> Integer
smallestMultiple n = foldl f 1 $ take n allPrimes
    where f = \ q p -> p ^ (floor $ log (fromIntegral n::Double) / log
              (fromIntegral p::Double)::Integer) * q

-- |The sumConsecSquares function returns the sum of the first n number
-- of squares beginning from i. The only parameter that requires a positive
-- integer is n. The function is defined over the RealFloat typeclass for the
-- other two parameters. The function returns the sum of squares of
-- i, i + j, i + 2*j,..., i + (n - 1)*j.
sumConsecSquares :: (RealFloat a, Integral b) => a -> b -> a -> a
sumConsecSquares i n j = (m + 1) * i ^ (2::Integer) + (m ^ (2::Integer) + m) *
                         i * j + (2 * m ^ (3::Integer) + 3 * m ^ (2::Integer) +
                         m) * j ^ (2::Integer) / 6
    where m = fromIntegral (n - 1)

-- |The primeNumber function returns the nth prime integer (indexed from 0).
-- The function takes some time to run so integers larger than 15000 shouldn't
-- be used.
primeNumber  :: Int -> Integer
primeNumber n = allPrimes !! n

-- |The digitProduct function returns a list containing the largest
-- product of m consecutive digits in n. If there are multiple instances
-- of the same product, there will be duplicate values.
digitProduct    :: Int -> [Integer] -> [Integer]
digitProduct m xs
    | length xs < m = []
    | otherwise     = product (take m xs) : digitProduct m ys
    where ys = drop 1 xs

-- |The digitProductTuple function returns a tuple containing a list
-- of each list of m consecutive integers that lead to the largest
-- possible product and the product itself.
digitProductTuple    :: Int -> Integer -> ([[Integer]], Integer)
digitProductTuple m n = ([take m $ drop i digits | i <- elemIndices max prod],
                         max)
    where (digits, prod, max) = (toDigits n, digitProduct m digits, maximum
                                 prod)
    
main :: IO()
main  = do print ((sumMultiple 3 1 ((999 `div` 3)::Integer)::Double) +
                  (sumMultiple 5 1 ((999 `div` 5)::Integer)::Double) -
                  (sumMultiple 15 1 ((999 `div` 15)::Integer)::Double))
           print (sum $ fibDiv 2 4000000)
           print (last $ factorization 600851475143)
           print (palindromeProduct 3)
           print (smallestMultiple 20)
           print ((sumConsecNumbers 1 (100::Integer) 1 ^ (2::Integer)::Double) -
                  (sumConsecSquares 1 (100::Integer) 1::Double))
           print (primeNumber 10000)
           print(digitProductTuple 13 [1000-digit number])
