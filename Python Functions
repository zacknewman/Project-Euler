from math import log, ceil

def product(iterable):
    """Return the product of every element in an iterable.
    
    The product of an empty iterable is returned as 0.
    
    >>> product(range(1, 8))
    5040
    """
    j = 1
    for i in iterable:
        j *= i
    return j

def sum_consec_numbers(start, quantity=None, step=1):
    """Return the sum of quantity-number of squares from start.
    
    The step parameter is defaulted at 1; and if only one positive
    integer argument is entered, then it defaults to calculating the
    sum of the integers 0 to (quantity - 1).
    
    The only parameter that requires a positive integer is quantity.
    The function works for all complex numbers for the start and step
    parameters. The function returns the sum of start, start + step,
    start + 2*step,..., start + (quantity - 1)*step.
    
    >>> sum_consec_numbers(10)
    45.0
    >>> sum_consec_numbers(2, 21, 2)
    462.0
    >>> sum_consec_numbers(complex(cmath.e, cmath.pi), 5,
                           complex(cmath.sqrt(2), cmath.pi**2))
    (27.733544766026178+114.40400727884256j)
    """
    if quantity is None:
        return sum_consec_numbers(0, start, 1)
    else:
        n = quantity - 1
        return (n + 1)*start + ((n**2 + n)*step)/2

def sum_multiple(mult, start, quantity=None):
    """Return the sum of quantity-number of multiples of mult.
    
    If only two arguments are entered, it defaults to calculating the
    sum of the first n multiples of mult starting from 0. All three
    parameters should be positive integers; otherwise incorrect
    results are possible.    
    >>> sum_multiple(2, 99)
    9702.0
    >>> sum_multiple(2, 7, 99)
    10494.0
    """
    if quantity is None:
        return sum_multiple(mult, 0, start)
    else:
        start = mult*ceil(start / mult)
        return sum_consec_numbers(start, quantity, mult)
    
def fib_div(i, n):
    """Generate all Fibonacci numbers > 0 and <= n and divisible by i.
        
    >>> list(fib_div(2,10))
    [2, 8]
    """
    a, b = 0, 1
    while b <= n:
        a, b = b, a + b
        if a % i == 0:
            yield a

def sum_fib_div(i, n):
    """Return the sum of all Fibonacci numbers <= n and divisible by i.
        
    >>> sum_fib_div(2, 10)
    10
    """
    return sum(fib_div(i, n))

def factorization(n):
    """Return a list of the prime factorization of n.
    
    This function is a rather simple implementation that can be
    greatly improved (e.g., general number field sieve); consequently
    this function may take a long time to compute if the number exceeds 20 digits.
    In the case of very large integers one must employ sieve theory
    techniques.
    
    >>> factorization(24)
    [2, 2, 2, 3]
    """
    primes = []
    p = 5
    q = 7
    while n % 2 == 0:
        primes.append(2)
        n //= 2
    while n % 3 == 0:
        primes.append(3)
        n //= 3
    while n > 1:
        while n % p == 0:
            primes.append(p)
            n //= p
        while n % q == 0:
            primes.append(q)
            n //= q
        p += 6
        q += 6
        if (p*p > n) and (n > 1):
            primes.append(n)
            break
    return primes

def palindromic_number(n):
    """Test if n is a palindromic number.
    
    >>> palindromic_number(1001)
    True
    >>> palindromic_number(1212)
    False
    """
    w = str(n)
    if w == w[::-1]:
        return True
    else:
        return False

def palindrome_product(digits):
    """Return a tuple containing a palindromic product of two numbers.
    
    The parameter, digits, is the number of digits the two numbers that
    will be multiplied have. The product of these two numbers is the
    largest possible palindromic number that's a result of multiplying
    any two numbers with that many digits.
    
    >>> palindrome_product(2)
    (99, 91, 9009)
    """
    n = int(10**digits - 1)
    m = int(10**(digits - 1) - 1)
    l = 0
    prod = ()
    for i in range(n, m, -1):
        for j in range(n, m, -1):
            k = i * j
            if palindromic_number(k) and k > l:
                l = k
                prod = (i, j, l)
            else:
                continue
    return prod

def prime(n):
    """Test if n is a prime number.
    
    This is a very simple function; consequently it may take a
    long time to compute if the number exceeds 20 digits.
    In the case of very large integers one must employ sieve theory
    techniques.
    
    >>> prime(19)
    True
    """
    if n == 2 or n == 3:
        return True
    elif n < 2 or (n % 6 != 5 and n % 6 != 1):
        return False
    else:
        j = int(n**0.5) + 1
        for i in range(5, j, 6):
            if n % i == 0:
                return False
        for k in range(7, j, 6):
            if n % k == 0:
                return False
        else:
            return True

def prime_generator(n):
    """Generate all unsorted primes <= n.
    
    >>> list(prime_generator(11))
    [2, 3, 5, 11, 7]
    """
    if n < 2:
        pass
    elif n == 2:
        yield 2
    elif n < 5:
        yield 2
        yield 3
    else:
        yield 2
        yield 3
        for i in range(5, n + 1, 6):
            if prime(i):
                yield i
        for j in range(7, n + 1, 6):
            if prime(j):
                yield j               

def smallest_multiple(n):
    """Return the smallest multiple of all numbers from 1 to n.
    
    >>> smallest_multiple(10)
    2520
    """
    primes = prime_generator(n)
    multiples = []
    for p in primes:
        q = int(p**(log(n) // log(p)))
        multiples.append(q)
    return product(multiples)

def sum_consec_squares(start, quantity=None, step=1):
    """Return the sum of quantity-number of squares from start.
    
    The step parameter is defaulted at 1; and if only one positive
    integer argument is entered, then it defaults to calculating the
    sum of squares of the integers 0 to (quantity - 1).
    
    The only parameter that requires a positive integer is quantity.
    The function works for all complex numbers for the start and step
    parameters. The function returns the sum of squares of start, start + step,
    start + 2*step,..., start + (quantity - 1)*step.
    
    >>> sum_consec_squares(10)
    285.0
    >>> sum_consec_squares(2, 21, 2)
    13244.0
    >>> sum_consec_squares(complex(cmath.e, cmath.pi), 5,
                           complex(cmath.sqrt(2), cmath.pi**2))
    (-3417.9163855736806+1548.286030897781j)
    """
    if quantity is None:
        return sum_consec_squares(0, start, 1)
    else:
        n = quantity - 1
        return ((n + 1)*start**2 + (n**2 + n)*start*step + ((2*n**3 + 3*n**2 +
                n)*step**2)/6)

def prime_number(n):
    """Return the nth prime number (indexed from 0).
    
    The function returns the nth prime integer (indexed from 0).
    The function takes some time to run, so integers larger than 1000000
    shouldn't be used.
    
    >>> prime_number(3)
    7
    """
    if n == 0:
        return 2
    elif n == 1:
        return 3
    else:
        p = 5
        q = 7
        i = 1
        while i < n:
            if prime(p):
                i += 1
            if prime(q):
                i += 1   
            p += 6
            q += 6
        if i == n and prime(q - 6):
            return q - 6
        else:
            return p - 6

def digit_product(n, m):
    """Return the largest product of m consecutive digits in n.
    
    A tuple containing the m digits as well as its product is returned.
    
    >>> digit_product(12345, 2)
    (4, 5, 20)
    """
    w = list(str(n))
    digits = []
    p = 0
    l = len(w)
    for i in w:
        digits.append(int(i))
    for j in range(l - m + 1):
        d = digits[j : j + m]
        k = product(d)
        if k > p:
            p = k
            d.append(p)
            answer = tuple(d)
    return answer

def pythagorean_triple_bound(n):
    """Return the Pythagorean triple whose sum is equal to n.
    
    A tuple containing the triple is returned; if there exists no such
    triple, then None is returned.
    
    >>> pythagorean_triple_bound(12)
    (3, 4, 5)
    >>> pythagorean_triple_bound(10)
    None
    """
    u = int(((4*n + 1)**(0.5) - 1)/2) + 1
    if u % 2 != 0:
        u -= 1
    l = ceil(((2*n + 1)**(0.5) + 1)/2)
    if l % 2 == 0:
        l += 1
    for i in range(l, u, 2):
        if n % i == 0:
            j = n//i - i
            return (i*j, (i**2 - j**2)//2, (i**2 + j**2)//2)
    else:
        return None
